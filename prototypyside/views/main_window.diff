--- a/prototypyside/views/main_window.py
+++ b/prototypyside/views/main_window.py
@@ -19,7 +19,7 @@
                                                      ImageElement, LabelElement,
                                                      ContainerElement)
 from prototypyside.views.graphics_view import DesignerGraphicsView
-
+from prototypyside.services.export_manager import ExportManager # NEW: Import ExportManager
 # Import constants (like MIN_ELEMENT_SIZE)
 from prototypyside.config import MIN_ELEMENT_SIZE
 
@@ -35,6 +35,7 @@
         self.palette_dock: Optional[QDockWidget] = None
         self.layers_dock: Optional[QDockWidget] = None
+        self._cli_mode = False # NEW: Flag to indicate CLI mode
 
         self.setup_ui()
         self.setup_status_bar() # Moved to after setup_ui calls so all elements are ready
@@ -67,6 +68,10 @@
         self.scene.element_dropped.connect(self.add_element_from_drop)
 
         self.create_menus()
+        self.export_manager = ExportManager() # NEW: Instantiate ExportManager here
+
+    def set_cli_mode(self, mode: bool): # NEW: Setter for CLI mode
+        self._cli_mode = mode
 
     def setup_shortcuts(self):
         delete_shortcut = QShortcut(QKeySequence.Delete, self) # Use QKeySequence.Delete for platform consistency
@@ -79,7 +84,8 @@
         self.status_message_timer.timeout.connect(self.clear_status_message)
 
     def show_status_message(self, message: str, message_type: str = "info", timeout_ms: int = 5000):
-        color = "black"
+        if self._cli_mode: # If in CLI mode, print to console instead of status bar
+            print(f"CLI {message_type.upper()}: {message}")
+            return
+
+        color = "black"
         if message_type == "info":
             color = "#0000FF"  # Blue
         elif message_type == "success":
@@ -93,6 +99,9 @@
         self.status_message_timer.start(timeout_ms)
 
     def clear_status_message(self):
+        if self._cli_mode:
+            return # No status bar to clear in CLI mode
+
         self.status_label.setStyleSheet("color: black;")
         self.status_label.setText("")
 
@@ -231,10 +240,10 @@
         actions_group = QGroupBox("Export Actions") # Renamed for clarity
         actions_layout = QVBoxLayout()
 
-        export_btn = QPushButton("Export as PNG")
-        export_btn.clicked.connect(self.export_template_as_png)
+        export_btn = QPushButton("Export as PNG") # Renamed for clarity
+        export_btn.clicked.connect(self.export_template_as_png_gui) # Connect to GUI specific method
         actions_layout.addWidget(export_btn)
 
-        export_pdf_btn = QPushButton("Export as PDF") # NEW: PDF Export button
-        export_pdf_btn.clicked.connect(self.export_to_pdf) # NEW: Connect to PDF export
+        export_pdf_btn = QPushButton("Export as PDF")
+        export_pdf_btn.clicked.connect(self.export_to_pdf_gui) # Connect to GUI specific method
         actions_layout.addWidget(export_pdf_btn)
 
         actions_group.setLayout(actions_layout)
@@ -298,10 +307,10 @@
         file_menu.addSeparator()
 
         export_action = file_menu.addAction("&Export as PNG...")
-        export_action.triggered.connect(self.export_template_as_png)
-
-        export_pdf_action = file_menu.addAction("Export as &PDF...") # NEW: PDF Menu Action
-        export_pdf_action.triggered.connect(self.export_to_pdf) # NEW: Connect PDF action
+        export_action.triggered.connect(self.export_template_as_png_gui) # Connect to GUI specific method
+
+        export_pdf_action = file_menu.addAction("Export as &PDF...")
+        export_pdf_action.triggered.connect(self.export_to_pdf_gui) # Connect to GUI specific method
 
         file_menu.addSeparator()
 
@@ -583,9 +592,6 @@
         else:
             self.show_status_message("Background image selection cancelled.", "info")
 
-    @Slot()
-    def update_game_component_scene(self):
-        self.scene.update()
 
     @Slot()
     def load_csv_and_merge(self):
@@ -609,7 +615,6 @@
                 reader = csv.reader(csvfile)
                 data_rows_raw = list(reader)
 
-                data_rows = []
                 for row_list in data_rows_raw:
                     if not row_list or len(row_list) < len(cleaned_headers):
                         if not cli_mode:
@@ -624,8 +629,6 @@
                         else:
                             print(f"CLI Warning: Skipping malformed row with too few columns in row {len(data_rows)+1}: {row_list}")
 
-
-                if not data_rows:
                     if not cli_mode:
                         self.show_status_message("CSV Merge Error: The CSV file is empty or has no data rows after processing headers.", "error")
                     else:
@@ -633,8 +636,6 @@
                     return
 
             self.merged_templates = []
-            # output_dir = Path("./merged_templates") # No longer needed here as export methods handle dir selection
-
             for i, row_data in enumerate(data_rows):
                 merged_template = GameComponentTemplate.from_dict(self.current_template.to_dict(), parent=None)
                 merged_template.background_image_path = self.current_template.background_image_path
@@ -677,100 +678,65 @@
             else:
                 print(f"CLI Error: An error occurred during merge: {str(e)}")
 
-    def _render_template_to_image(self, template: GameComponentTemplate) -> Optional[QImage]:
-        image = QImage(template.width_px, template.height_px, QImage.Format_ARGB32)
-        image.fill(Qt.transparent)
-
-        painter = QPainter(image)
-        painter.setRenderHints(QPainter.Antialiasing | QPainter.TextAntialiasing | QPainter.SmoothPixmapTransform)
-
-        if template.background_image_path:
-            bg_pixmap = QPixmap(template.background_image_path)
-            if not bg_pixmap.isNull():
-                scaled_bg = bg_pixmap.scaled(
-                    QSize(template.width_px, template.height_px),
-                    Qt.IgnoreAspectRatio,
-                    Qt.SmoothTransformation
-                )
-                painter.drawPixmap(0, 0, scaled_bg)
-
-        temp_scene = GameComponentGraphicsScene(template.width_px, template.height_px, None)
-        for element in template.elements:
-            temp_scene.addItem(element)
-
-        temp_scene.render(painter,
-                          QRectF(0, 0, template.width_px, template.height_px),
-                          temp_scene.sceneRect())
-        painter.end()
-
-        for item in temp_scene.items():
-            temp_scene.removeItem(item)
-        del temp_scene
-
-        return image
-
-    @Slot()
-    def export_template_as_png(self, output_path: Optional[Path] = None, cli_mode: bool = False): # Modified signature
+    # --- GUI Export Methods (delegate to ExportManager) ---
+
+    @Slot()
+    def export_template_as_png_gui(self): # Renamed for clarity
         if self.merged_templates:
-            if not cli_mode:
-                output_dir = QFileDialog.getExistingDirectory(self, "Select Output Directory for Merged PNGs")
-                if not output_dir:
-                    self.show_status_message("PNG Export cancelled.", "info")
-                    return
-                output_path = Path(output_dir)
-            else: # CLI mode: output_path is already a directory
-                if not output_path:
-                    print("CLI Error: Output directory not provided for merged PNG export.")
-                    return
-                output_path.mkdir(parents=True, exist_ok=True) # Ensure dir exists
-
-            export_count = 0
-            for i, template_instance in enumerate(self.merged_templates):
-                image = self._render_template_to_image(template_instance)
-                if image:
-                    filename = f"merged_output_{i+1}.png"
-                    current_output_file = output_path / filename
-                    try:
-                        if image.save(str(current_output_file)):
-                            export_count += 1
-                        else:
-                            if not cli_mode:
-                                self.show_status_message(f"Error: Failed to save {filename}.", "error")
-                            else:
-                                print(f"CLI Error: Failed to save {current_output_file}")
-                    except Exception as e:
-                        if not cli_mode:
-                            self.show_status_message(f"Error saving {filename}: {e}", "error")
-                        else:
-                            print(f"CLI Error: Exception saving {current_output_file}: {e}")
-                else:
-                    if not cli_mode:
-                        self.show_status_message(f"Warning: Could not render merged template {i+1} for PNG export.", "warning")
-                    else:
-                        print(f"CLI Warning: Could not render merged template {i+1} for PNG export.")
-
-            if export_count > 0:
-                self.show_status_message(f"Successfully exported {export_count} merged templates to {output_path.resolve()}", "success")
-            else:
-                self.show_status_message("PNG Export Failed: No merged templates were exported.", "error")
-        else:
-            path, _ = QFileDialog.getSaveFileName(
-                self, "Export Current Template as PNG", "game_component_design.png", "PNG Files (*.png)",
-                options=QFileDialog.Options()) # Removed options=options which was causing an issue here
-                if not path:
-                    self.show_status_message("PNG Export cancelled.", "info")
-                    return
-                output_path = Path(path) # Convert string path to Path object
-            else: # CLI mode for single template export
-                if not output_path:
-                    print("CLI Error: Output path not provided for single PNG export.")
-                    return
-                # Ensure parent directory exists for single file export in CLI mode
-                output_path.parent.mkdir(parents=True, exist_ok=True)
-
-            image = self._render_template_to_image(self.current_template)
-            if image:
-                try:
-                    if image.save(str(output_path)):
-                        self.show_status_message(f"Current template exported to {output_path}", "success")
-                    else:
-                        if not cli_mode:
-                            self.show_status_message("PNG Export Failed: Could not save image. Check file path and permissions.", "error")
-                        else:
-                            print(f"CLI Error: Failed to save current template to {output_path}")
-                except Exception as e:
-                    if not cli_mode:
-                        self.show_status_message(f"Error saving PNG: {e}", "error")
-                    else:
-                        print(f"CLI Error: Exception saving PNG: {e}")
-            else:
-                if not cli_mode:
-                    self.show_status_message("PNG Export Failed: Could not render current template.", "error")
-                else:
-                    print("CLI Error: Could not render current template for PNG export.")
-
-    # NEW: Export all merged templates for CLI (simplifies main.py logic)
-    def export_all_merged_cli(self, output_dir: Path):
-        self.export_template_as_png(output_path=output_dir, cli_mode=True)
-
-
-    @Slot()
-    def export_to_pdf(self, output_path: Optional[Path] = None, cli_mode: bool = False): # Modified signature
+            templates_to_export = self.merged_templates
+        else:
+            templates_to_export = [self.current_template]
+
+        if not templates_to_export:
+            self.show_status_message("PNG Export Failed: No templates to export.", "error")
+            return
+
+        output_dir_str = QFileDialog.getExistingDirectory(self, "Select Output Directory for PNGs")
+        if not output_dir_str:
+            self.show_status_message("PNG Export cancelled.", "info")
+            return
+
+        output_dir = Path(output_dir_str)
+        
+        if self.export_manager.export_png(templates_to_export, output_dir=output_dir, is_cli_mode=False):
+            self.show_status_message(f"Successfully exported PNG(s) to {output_dir.resolve()}", "success")
+        else:
+            # ExportManager will handle detailed messages via print in CLI mode,
+            # but for GUI mode, we should explicitly report errors here if ExportManager returns False.
+            self.show_status_message("PNG Export Failed.", "error")
+
+
+    @Slot()
+    def export_to_pdf_gui(self): # Renamed for clarity
+        templates_to_export = self.merged_templates if self.merged_templates else [self.current_template]
+
+        if not templates_to_export:
+            self.show_status_message("PDF Export Failed: No templates to export.", "error")
+            return
+
+        path_str, _ = QFileDialog.getSaveFileName(
+            self, "Export to PDF", "merged_output.pdf", "PDF Files (*.pdf)") # Suggest merged_output.pdf by default
+        
+        if not path_str:
+            self.show_status_message("PDF Export cancelled.", "info")
+            return
+
+        output_file_path = Path(path_str)
+
+        if self.export_manager.export_pdf(templates_to_export, output_file_path=output_file_path, is_cli_mode=False):
+            self.show_status_message(f"Successfully exported PDF to {output_file_path.resolve()}", "success")
+        else:
+            # Re-raise QMessageBox.critical here if a critical error occurs, or rely on status bar for general failure
+            # For now, consistent with previous behavior, let's keep the QMessageBox for critical PDF errors.
+            # The ExportManager prints for CLI, so this part is for GUI error feedback.
+            QMessageBox.critical(self, "PDF Export Error", "An error occurred during PDF export.")
+            self.show_status_message(f"PDF Export Failed.", "error")
+
+    # --- CLI Export Methods (public for main.py to call) ---
+
+    def export_png_cli(self, output_dir: Path): # NEW: CLI-specific PNG export
+        templates_to_export = self.merged_templates if self.merged_templates else [self.current_template]
+        self.export_manager.export_png(templates_to_export, output_dir=output_dir, is_cli_mode=True)
+
+    def export_pdf_cli(self, output_dir: Path): # NEW: CLI-specific PDF export
+        templates_to_export = self.merged_templates if self.merged_templates else [self.current_template]
+        # For PDF, the ExportManager expects a full file path, not just a directory.
+        # We'll default to 'merged_output.pdf' or 'current_template.pdf' within the output_dir.
+        pdf_output_name = "merged_output.pdf" if self.merged_templates else "current_template.pdf"
+        self.export_manager.export_pdf(templates_to_export, output_file_path=output_dir / pdf_output_name, is_cli_mode=True)
+
+
+    def set_element_controls_enabled(self, enabled: bool):
+        self.name_edit.setEnabled(enabled)
+        self.content_edit.setEnabled(enabled)
+        self.x_spin.setEnabled(enabled)
+        self.y_spin.setEnabled(enabled)
+        self.width_spin.setEnabled(enabled)
+        self.height_spin.setEnabled(enabled)
+        self.color_btn.setEnabled(enabled)
+        self.bg_color_btn.setEnabled(enabled)
+        self.border_color_btn.setEnabled(enabled)
+        self.border_width_spin.setEnabled(enabled)
+        self.alignment_combo.setEnabled(enabled)
+        self.remove_element_btn.setEnabled(enabled)
+
+
+    @Slot()
+    def remove_selected_element(self):
+        element = self.get_selected_element()
+        if element:
+            reply = QMessageBox.question(self, "Remove Element",
+                                         f"Are you sure you want to remove '{element.name}'?",
+                                         QMessageBox.Yes | QMessageBox.No)
+            if reply == QMessageBox.No:
+                self.show_status_message("Element removal cancelled.", "info")
+                return
+            self.scene.removeItem(element)
+            self.current_template.remove_element(element)
+            self.on_selection_changed()
+            self.show_status_message(f"Element '{element.name}' removed.", "info")
+        else:
+            self.show_status_message("No element selected to remove.", "warning")
+
+
+    #### Paint Toolbar ####
+
+    @Slot()
+    def on_color_picker_clicked(self):
+        color = QColorDialog.getColor(self._current_drawing_color, self, "Select Drawing Color")
+        if color.isValid():
+            self._current_drawing_color = color
+            self.update_color_display()
+            self.show_status_message(f"Drawing color set to {color.name()}.", "info")
+        else:
+            self.show_status_message("Color picker cancelled.", "info")
+
+
+    @Slot()
+    def on_fill_tool_clicked(self):
+        self.show_status_message("Fill tool selected. Click on an area to fill.", "info")
+
+    @Slot()
+    def on_eraser_tool_clicked(self):
+        self.show_status_message("Eraser tool selected. Drag to erase.", "info")
+
+    @Slot()
+    def on_brush_tool_clicked(self):
+        self.show_status_message("Brush tool selected. Drag to draw.", "info")
+
+    def update_color_display(self):
+        self.current_color_display.setStyleSheet(f"background-color: {self._current_drawing_color.name()}; border: 1px solid black;")